<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/appbibliofilia/ui/BookCRUDScreen/BooksViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/appbibliofilia/ui/BookCRUDScreen/BooksViewModel.kt" />
              <option name="originalContent" value="package com.example.appbibliofilia.ui.BookCRUDScreen&#10;&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.appbibliofilia.data.repository.LibrosRepository&#10;import kotlinx.coroutines.launch&#10;&#10;class BooksViewModel(private val repo: LibrosRepository? = null) : ViewModel() {&#10;    private val _books = mutableStateListOf&lt;Book&gt;()&#10;    val books: List&lt;Book&gt; get() = _books&#10;&#10;    private var nextId = 1L&#10;&#10;    private val _editingId = mutableStateOf&lt;Long?&gt;(null)&#10;    val editingId: Long? get() = _editingId.value&#10;&#10;    private val _isLoading = mutableStateOf(false)&#10;    val isLoading: Boolean get() = _isLoading.value&#10;&#10;    private val _errorMessage = mutableStateOf(&quot;&quot;)&#10;    val errorMessage: String get() = _errorMessage.value&#10;&#10;    init {&#10;        // si recibimos repo, cargar al iniciar&#10;        if (repo != null) {&#10;            loadBooks()&#10;        }&#10;    }&#10;&#10;    fun loadBooks() {&#10;        val r = repo ?: return&#10;        _isLoading.value = true&#10;        viewModelScope.launch {&#10;            try {&#10;                val res = r.getLibros()&#10;                if (res.isSuccess) {&#10;                    _books.clear()&#10;                    _books.addAll(res.getOrThrow())&#10;                    // asegurar nextId mayor que el mayor id en la lista&#10;                    val maxId = _books.maxOfOrNull { it.id } ?: 0L&#10;                    nextId = maxId + 1&#10;                    _errorMessage.value = &quot;&quot;&#10;                } else {&#10;                    _errorMessage.value = res.exceptionOrNull()?.localizedMessage ?: &quot;Error al cargar libros&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = e.localizedMessage ?: &quot;Error inesperado&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun addBook(name: String, author: String, format: BookFormat) {&#10;        val book = Book(id = nextId++, name = name, author = author, format = format)&#10;        _books.add(0, book)&#10;        // intentar crear en remoto si hay repo&#10;        repo?.let { r -&gt;&#10;            viewModelScope.launch {&#10;                val res = r.crearLibro(book)&#10;                if (res.isFailure) {&#10;                    // opcional: marcar error pero mantener el libro local&#10;                    _errorMessage.value = res.exceptionOrNull()?.localizedMessage ?: &quot;Error al crear libro&quot;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateBook(id: Long, name: String, author: String, format: BookFormat) {&#10;        val index = _books.indexOfFirst { it.id == id }&#10;        if (index &gt;= 0) {&#10;            val updated = Book(id = id, name = name, author = author, format = format)&#10;            _books[index] = updated&#10;            repo?.let { r -&gt;&#10;                viewModelScope.launch {&#10;                    val res = r.actualizarLibro(updated)&#10;                    if (res.isFailure) {&#10;                        _errorMessage.value = res.exceptionOrNull()?.localizedMessage ?: &quot;Error al actualizar libro&quot;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteBook(id: Long) {&#10;        _books.removeAll { it.id == id }&#10;        if (editingId == id) editingId = null&#10;        repo?.let { r -&gt;&#10;            viewModelScope.launch {&#10;                val res = r.eliminarLibro(id)&#10;                if (res.isFailure) {&#10;                    _errorMessage.value = res.exceptionOrNull()?.localizedMessage ?: &quot;Error al eliminar libro&quot;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startEditing(id: Long) {&#10;        _editingId.value = id&#10;    }&#10;&#10;    fun stopEditing() {&#10;        _editingId.value = null&#10;    }&#10;&#10;    fun getBook(id: Long): Book? = _books.find { it.id == id }&#10;}&#10;&#10;// Factory simple para crear el ViewModel con repo&#10;class BooksViewModelFactory(private val repo: LibrosRepository?) : androidx.lifecycle.ViewModelProvider.Factory {&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(BooksViewModel::class.java)) {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            return BooksViewModel(repo) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.appbibliofilia.ui.BookCRUDScreen&#10;&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.appbibliofilia.data.repository.LibrosRepository&#10;import kotlinx.coroutines.launch&#10;&#10;class BooksViewModel(private val repo: LibrosRepository? = null) : ViewModel() {&#10;    private val _books = mutableStateListOf&lt;Book&gt;()&#10;    val books: List&lt;Book&gt; get() = _books&#10;&#10;    private var nextId = 1L&#10;&#10;    private val _editingId = mutableStateOf&lt;Long?&gt;(null)&#10;    val editingId: Long? get() = _editingId.value&#10;&#10;    private val _isLoading = mutableStateOf(false)&#10;    val isLoading: Boolean get() = _isLoading.value&#10;&#10;    private val _errorMessage = mutableStateOf(&quot;&quot;)&#10;    val errorMessage: String get() = _errorMessage.value&#10;&#10;    init {&#10;        // si recibimos repo, cargar al iniciar&#10;        if (repo != null) {&#10;            loadBooks()&#10;        }&#10;    }&#10;&#10;    fun loadBooks() {&#10;        val r = repo ?: return&#10;        _isLoading.value = true&#10;        viewModelScope.launch {&#10;            try {&#10;                val res = r.getLibros()&#10;                if (res.isSuccess) {&#10;                    _books.clear()&#10;                    _books.addAll(res.getOrThrow())&#10;                    // asegurar nextId mayor que el mayor id en la lista&#10;                    val maxId = _books.maxOfOrNull { it.id } ?: 0L&#10;                    nextId = maxId + 1&#10;                    _errorMessage.value = &quot;&quot;&#10;                } else {&#10;                    _errorMessage.value = res.exceptionOrNull()?.localizedMessage ?: &quot;Error al cargar libros&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = e.localizedMessage ?: &quot;Error inesperado&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun addBook(name: String, author: String, format: BookFormat) {&#10;        val book = Book(id = nextId++, name = name, author = author, format = format)&#10;        _books.add(0, book)&#10;        // intentar crear en remoto si hay repo&#10;        repo?.let { r -&gt;&#10;            viewModelScope.launch {&#10;                val res = r.crearLibro(book)&#10;                if (res.isFailure) {&#10;                    // opcional: marcar error pero mantener el libro local&#10;                    _errorMessage.value = res.exceptionOrNull()?.localizedMessage ?: &quot;Error al crear libro&quot;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateBook(id: Long, name: String, author: String, format: BookFormat) {&#10;        val index = _books.indexOfFirst { it.id == id }&#10;        if (index &gt;= 0) {&#10;            val updated = Book(id = id, name = name, author = author, format = format)&#10;            _books[index] = updated&#10;            repo?.let { r -&gt;&#10;                viewModelScope.launch {&#10;                    val res = r.actualizarLibro(updated)&#10;                    if (res.isFailure) {&#10;                        _errorMessage.value = res.exceptionOrNull()?.localizedMessage ?: &quot;Error al actualizar libro&quot;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteBook(id: Long) {&#10;        _books.removeAll { it.id == id }&#10;        if (_editingId.value == id) _editingId.value = null&#10;        repo?.let { r -&gt;&#10;            viewModelScope.launch {&#10;                val res = r.eliminarLibro(id)&#10;                if (res.isFailure) {&#10;                    _errorMessage.value = res.exceptionOrNull()?.localizedMessage ?: &quot;Error al eliminar libro&quot;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startEditing(id: Long) {&#10;        _editingId.value = id&#10;    }&#10;&#10;    fun stopEditing() {&#10;        _editingId.value = null&#10;    }&#10;&#10;    fun getBook(id: Long): Book? = _books.find { it.id == id }&#10;}&#10;&#10;// Factory simple para crear el ViewModel con repo&#10;class BooksViewModelFactory(private val repo: LibrosRepository?) : androidx.lifecycle.ViewModelProvider.Factory {&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(BooksViewModel::class.java)) {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            return BooksViewModel(repo) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>